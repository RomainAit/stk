Index: stk/stk_init.m
===================================================================
--- stk.orig/stk_init.m
+++ stk/stk_init.m
@@ -53,9 +53,6 @@ switch command
     case 'pkg_unload'
         stk_init__pkg_unload (root);
         
-    case 'prune_mole'
-        stk_init__config_mole (root, false, true);  % prune, but do not add to path
-        
     case 'clear_persistents'
         % Note: this implies munlock
         stk_init__clear_persistents ();
@@ -181,9 +178,6 @@ end
 % Add STK folders to the path
 addpath (path{:});
 
-% Selectively add MOLE subdirectories to compensate for missing functions
-stk_init__config_mole (root, true, false);  % (add to path, but do not prune)
-
 end % function
 
 
@@ -279,78 +273,3 @@ s = strrep (s, '+', '\+');
 s = strrep (s, '.', '\.');
 
 end % function
-
-
-function stk_init__config_mole (root, do_addpath, prune_unused)
-
-mole_dir = fullfile (root, 'misc', 'mole');
-isoctave = (exist ('OCTAVE_VERSION', 'builtin') == 5);
-
-if isoctave
-    recursive_rmdir_state = confirm_recursive_rmdir (0);
-end
-
-opts = {root, mole_dir, do_addpath, prune_unused};
-
-% Provide missing octave functions for Matlab users
-% TODO: extract functions that are REALLY needed in separate directories
-%       and get rid of the others !
-if (exist ('OCTAVE_VERSION', 'builtin') ~= 5)  % if Matlab
-    if do_addpath
-        addpath (fullfile (mole_dir, 'matlab'));
-    end
-elseif prune_unused
-    rmdir (fullfile (mole_dir, 'matlab'), 's');
-end
-
-% graphics_toolkit
-%  * For Octave users: available in Octave >= 4.0.0
-%  * For Matlab users: there is no function named graphics_toolkit in Matlab.
-%    Our implementation returns either 'matlab-jvm' or 'matlab-nojvm'.
-install_mole_function ('graphics_toolkit', opts{:});
-
-% quantile
-%  * For Octave users: available in Octave >= 4.0.0
-%  * For Matlab users: quantile is missing from Matlab itself, but it provided
-%    by the Statistics toolbox if you're rich enough to afford it.
-install_mole_function ('quantile', opts{:});
-
-% cleanup
-if isoctave
-    confirm_recursive_rmdir (recursive_rmdir_state);
-end
-
-end % function
-
-
-function install_mole_function (funct_name, ...
-    root, mole_dir, do_addpath, prune_unused)
-
-function_dir = fullfile (mole_dir, funct_name);
-
-w = which (funct_name);
-
-if (isempty (w)) || (~ isempty (strfind (w, root)))  %#ok<STREMP> % if the function is absent
-    
-    function_mfile = fullfile (function_dir, [funct_name '.m']);
-    
-    if exist (function_dir, 'dir') && exist (function_mfile, 'file')
-        
-        % fprintf ('[MOLE]  Providing function %s\n', function_name);
-        if do_addpath
-            addpath (function_dir);
-        end
-        
-    else
-        
-        warning (sprintf ('[MOLE]  Missing function: %s\n', funct_name));
-        
-    end
-    
-elseif prune_unused && (exist (function_dir, 'dir'))
-    
-    rmdir (function_dir, 's');
-    
-end
-
-end % function
Index: stk/misc/mole/README
===================================================================
--- stk.orig/misc/mole/README
+++ /dev/null
@@ -1,33 +0,0 @@
-What is the MOLE ?
-==================
-
-MOLE stands for "Matlab/Octave Langage Extensions"
-
-This directory is meant to contain general purpose functions that either extend
-the Matlab/Octave langage or provided a replacement for a function that is
-missing or buggy in one of the two langages.
-
-
-Long-term goal
-==============
-
-The MOLE might one day be released as a package on its own, independently of
-STK. Therefore, here, functions DO NOT have their name prefixed by stk_.
-
-
-Directories
-===========
-
-./matlab contains functions that are missing in Matlab:
-
-      o fflush
-      o file_in_loadpath
-      o file_in_path
-      o index
-      o page_screen_output
-      o stdout
-
-Other functions are provided in single-function subdirectories:
-
-      o graphics_toolkit
-      o quantile
Index: stk/misc/mole/graphics_toolkit/graphics_toolkit.m
===================================================================
--- stk.orig/misc/mole/graphics_toolkit/graphics_toolkit.m
+++ /dev/null
@@ -1,69 +0,0 @@
-% GRAPHICS_TOOLKIT indicates which toolkit is assigned to new figures.
-%
-% This is a (partial) replacement for the graphics_toolkit function that is missing both
-% from Matlab and from some old version f Octave.
-%
-% CALL: NAME = graphics_toolkit ()
-%
-%   returns:
-%
-%    * the result of get (0, 'defaultfigure__backend__') if you're running an old version
-%      of Octave that does not have graphics_toolkit,
-%
-%    * 'matlab-nojvm' if running Matlab without the Java Virtual Machine,
-%
-%    * 'matlab-jvm' if running Matlab with the Java Virtual Machine.
-
-% Copyright Notice
-%
-%    Copyright (C) 2013, 2014 SUPELEC
-%
-%    Author:  Julien Bect  <julien.bect@centralesupelec.fr>
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-
-function name = graphics_toolkit ()
-
-if exist ('OCTAVE_VERSION', 'builtin') == 5  % Octave
-    
-    try
-        % This should work on older versions of Octave, e.g., 3.2.4
-        % (there was no notion of a 'toolkit' at the time, but if gnuplot
-        %  is reported as the backend, then it is also the toolkit)
-        name = get (0, 'defaultfigure__backend__');
-    catch
-        error ('Unable to determine which toolkit is being used.');
-    end
-    
-else  % Matlab
-    
-    try
-        assert (usejava ('jvm'));
-        name = 'matlab-jvm';
-    catch
-        name = 'matlab-nojvm';
-    end
-    
-end
-
-end % function
-
-%#ok<*CTCH>
Index: stk/misc/mole/matlab/fflush.m
===================================================================
--- stk.orig/misc/mole/matlab/fflush.m
+++ /dev/null
@@ -1,37 +0,0 @@
-% FFLUSH does nothing (provided for Matlab/Octave compatibility)
-
-% Copyright Notice
-%
-%    Copyright (C) 2012 SUPELEC
-%
-%    Authors:   Julien Bect        <julien.bect@centralesupelec.fr>
-%               Emmanuel Vazquez   <emmanuel.vazquez@centralesupelec.fr>
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-
-function fflush(fid) %#ok<INUSD>
-
-% According to this blog entry (Lauren Shore from TMW, 2006/04/19)
-% http://blogs.mathworks.com/loren/2006/04/19/high-performance-file-io
-% "The default behavior for fprintf and fwrite is to flush the file buffer
-% after each call to either of these functions."...
-
-end % function
Index: stk/misc/mole/matlab/file_in_loadpath.m
===================================================================
--- stk.orig/misc/mole/matlab/file_in_loadpath.m
+++ /dev/null
@@ -1,49 +0,0 @@
-% FILE_IN_LOADPATH searches for a given filename in the the path.
-%
-% This functions is provided as a replacement for Octave's file_in_loadpath()
-% function when using STK with Matlab.
-
-% Copyright Notice
-%
-%    Copyright (C) 2018 CentraleSupelec
-%    Copyright (C) 2012 SUPELEC
-%
-%    Author:  Julien Bect  <julien.bect@centralesupelec.fr>
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-
-function name = file_in_loadpath(filename, flag)
-
-if nargin < 2, flag = ''; end
-
-searchpath = [pwd pathsep() path()];
-name = file_in_path(searchpath, filename, flag);
-
-if isempty(name),
-    % maybe an absolute path ?
-    fid = fopen(filename);
-    if fid ~= -1,
-        name = {filename};
-        fclose(fid);
-    end
-end
-
-end % function
Index: stk/misc/mole/matlab/file_in_path.m
===================================================================
--- stk.orig/misc/mole/matlab/file_in_path.m
+++ /dev/null
@@ -1,97 +0,0 @@
-% FILE_IN_PATH searches for a given filename in a list of directories.
-%
-% This functions is provided as a replacement for Octave's file_in_path()
-% function when using STK with Matlab.
-
-% Copyright Notice
-%
-%    Copyright (C) 2015, 2018 CentraleSupelec
-%    Copyright (C) 2012 SUPELEC
-%
-%    Author:  Julien Bect  <julien.bect@centralesupelec.fr>
-%
-%    This file is based on the Oct2mat package, version 1.0.7. The
-%    following information was provided in the DESCRIPTION of the
-%    package:
-%
-%        Name: Oct2Mat
-%        Version: 1.0.7
-%        Date: 2008-08-23
-%        Author: Paul Kienzle
-%        Maintainer: Alois Schloegl
-%        Title: Oct2Mat
-%        Description: convert m-file into matlab-compatible coding style
-%        Categories: graphics
-%        Depends: octave (>= 2.9.7), io (>= 1.0.0)
-%        License: GPL version 2 or later
-%        Url: http://octave.sf.net
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-
-function loc = file_in_path(dirlist, filename, flag)
-
-if nargin < 3, flag = ''; end
-
-if iscell(filename),
-    for i = 1:numel(filename),
-        loc = file_in_path_(dirlist, filename{i}, flag);
-        if ~isempty(loc), break; end
-    end
-else
-    loc = file_in_path_(dirlist, filename, flag);
-end
-
-end % function
-
-%%%%%%%%%%%%%%%%%
-% file_in_path_ %
-%%%%%%%%%%%%%%%%%
-
-function loc = file_in_path_(dirlist, filename, flag)
-
-idx = [0, strfind(dirlist, pathsep), length(dirlist) + 1];
-% note: using strtok() is more elegant... but much slower !
-
-get_all = strcmp(flag, 'all');
-loc = {};
-
-for i = 1:length(idx) - 1,
-    pos1 = idx(i) + 1;
-    pos2 = idx(i+1) - 1;
-    dirname = dirlist(pos1:pos2);
-    fullfn = fullfile(dirname, filename);
-    try
-        % note: fopen (fullfn, 'r') is much faster than exist (fullfn, 'file')
-        fid = fopen (fullfn, 'r');
-    catch
-        fid = -1;
-    end
-    if fid ~= -1,
-        fclose(fid);
-        if get_all,
-            loc = [loc; {fullfn}]; %#ok<AGROW>
-        else
-            loc = fullfn; break
-        end
-    end
-end
-
-end % function
Index: stk/misc/mole/matlab/index.m
===================================================================
--- stk.orig/misc/mole/matlab/index.m
+++ /dev/null
@@ -1,124 +0,0 @@
-% INDEX finds the first (or last) occurence of one string within another.
-%
-% CALL: index(S, T)
-% CALL: index(S, T, "first")
-%   Returns the position of the first occurrence of the string T in the
-%   string S, or 0 if no occurrence is found. S may also be a cell array
-%   of strings.
-%
-% CALL: index(S, T, "last")
-%   Returns the position of the last occurrence.
-%
-% EXAMPLES:
-%   index("Teststring", "t")            returns 4
-%   index('Teststring', 't', 'last')    returns 6
-%   index({'Hello', 'Toto'}, 'o')        returns [5 2]
-%
-% SEE ALSO:
-%   strfind
-
-% Copyright Notice
-%
-%    Copyright (C) 2012 SUPELEC
-%
-%    Authors:   Julien Bect        <julien.bect@centralesupelec.fr>
-%               Emmanuel Vazquez   <emmanuel.vazquez@centralesupelec.fr>
-%
-%    This file has been adapted from index.m in Octave 3.6.2, distributed
-%    under the GNU General Public Licence version 3 (GPLv3). The original
-%    copyright notice and authorship statement were as follows:
-%
-%        Copyright (C) 1996-2012 Kurt Hornik
-%
-%        Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
-%        Adapted-By: jwe
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-
-function n = index (s, t, direction)
-
-if nargin < 3, direction = 'first'; end
-
-if ischar(s)
-    if size(s, 1) > 1
-        s = cellstr (s);  % Handle string arrays by conversion to cellstr
-    end
-elseif ~ iscellstr (s)  %#ok<ISCLSTR> 
-    error ('index: S must be a string, string array, or cellstr');
-end
-
-f = strfind (s, t);
-if (isempty (f))
-    f = 0;
-elseif (iscell (f))
-    f(cellfun ('isempty', f)) = {0};
-end
-
-direction = lower (direction);
-
-if (strcmp (direction, 'first'))
-    if (iscell (f))
-        n = cellfun (@min, f);
-    else
-        n = f(1);
-    end
-elseif (strcmp (direction, 'last'))
-    if (iscell (f))
-        n = cellfun (@max, f);
-    else
-        n = f(end);
-    end
-else
-    error ('index: DIRECTION must be either "first" or "last"');
-end
-
-end % function
-
-
-%!assert (index ('foobarbaz', 'b') == 4 && index ('foobarbaz', 'z') == 9);
-
-%!assert (isequal (index ('astringbstringcstring', 's'), 2))
-%!assert (isequal (index ('astringbstringcstring', 'st'), 2))
-%!assert (isequal (index ('astringbstringcstring', 'str'), 2))
-%!assert (isequal (index ('astringbstringcstring', 'string'), 2))
-%!assert (isequal (index ('abc---', 'abc+++'), 0))
-
-%% test everything out in reverse
-%!assert (isequal (index ('astringbstringcstring', 's', 'last'), 16))
-%!assert (isequal (index ('astringbstringcstring', 'st', 'last'), 16))
-%!assert (isequal (index ('astringbstringcstring', 'str', 'last'), 16))
-%!assert (isequal (index ('astringbstringcstring', 'string', 'last'), 16))
-%!assert (isequal (index ('abc---', 'abc+++', 'last'), 0))
-
-%!test
-%! str = char ('Hello', 'World', 'Goodbye', 'World');
-%! assert (isequal (index (str, 'o'), [5; 2; 2; 2]));
-%! assert (isequal (index (str, 'o', 'last'), [5; 2; 3; 2]));
-%! str = cellstr (str);
-%! assert (isequal (index (str, 'o'), [5; 2; 2; 2]));
-%! assert (isequal (index (str, 'o', 'last'), [5; 2; 3; 2]));
-
-%% Test input validation
-%!error index ()
-%!error index ('a')
-%!error index ('a', 'b', 'first', 'd')
-%!error index (1, 'bar')
-%!error index ('foo', 'bar', 3)
Index: stk/misc/mole/matlab/stdout.m
===================================================================
--- stk.orig/misc/mole/matlab/stdout.m
+++ /dev/null
@@ -1,38 +0,0 @@
-% STDOUT gives the FID of the standard output stream
-
-% Copyright Notice
-%
-%    Copyright (C) 2012 SUPELEC
-%
-%    Authors:   Julien Bect        <julien.bect@centralesupelec.fr>
-%               Emmanuel Vazquez   <emmanuel.vazquez@centralesupelec.fr>
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-%
-function fid = stdout()
-
-% Octave has a builtin function that gives the FID of STDOUT, Matlab
-% doesn't... but, according to fprintf()'s doc, stdout always corresponds
-% to FID = 1.
-
-fid = 1;
-
-end % function
Index: stk/misc/mole/quantile/quantile.m
===================================================================
--- stk.orig/misc/mole/quantile/quantile.m
+++ /dev/null
@@ -1,463 +0,0 @@
-% QUANTILE ...
-
-% Copyright Notice
-%
-%    Copyright (C) 2013 SUPELEC
-%
-%    Author: Julien Bect  <julien.bect@centralesupelec.fr>
-%
-%    The function comes from Octave 3.7.6+'s quantile.m, with minor
-%    modifications. The original copyright notice was:
-%
-%       Copyright (C) 2008-2012 Ben Abbott and Jaroslav Hajek
-
-% Copying Permission Statement
-%
-%    This file is part of
-%
-%            STK: a Small (Matlab/Octave) Toolbox for Kriging
-%               (https://github.com/stk-kriging/stk/)
-%
-%    STK is free software: you can redistribute it and/or modify it under
-%    the terms of the GNU General Public License as published by the Free
-%    Software Foundation,  either version 3  of the License, or  (at your
-%    option) any later version.
-%
-%    STK is distributed  in the hope that it will  be useful, but WITHOUT
-%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY
-%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public
-%    License for more details.
-%
-%    You should  have received a copy  of the GNU  General Public License
-%    along with STK.  If not, see <http://www.gnu.org/licenses/>.
-
-% ## Copyright (C) 2008-2012 Ben Abbott and Jaroslav Hajek
-% ##
-% ## This file is part of Octave.
-% ##
-% ## Octave is free software; you can redistribute it and/or modify it
-% ## under the terms of the GNU General Public License as published by
-% ## the Free Software Foundation; either version 3 of the License, or (at
-% ## your option) any later version.
-% ##
-% ## Octave is distributed in the hope that it will be useful, but
-% ## WITHOUT ANY WARRANTY; without even the implied warranty of
-% ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-% ## General Public License for more details.
-% ##
-% ## You should have received a copy of the GNU General Public License
-% ## along with Octave; see the file COPYING.  If not, see
-% ## <http://www.gnu.org/licenses/>.
-%
-% ## -*- texinfo -*-
-% ## @deftypefn  {Function File} {@var{q} =} quantile (@var{x})
-% ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p})
-% ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim})
-% ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
-% ## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
-% ## the cumulative probability values in @var{p}.  All non-numeric values (NaNs)
-% ## of @var{x} are ignored.
-% ##
-% ## If @var{x} is a matrix, compute the quantiles for each column and
-% ## return them in a matrix, such that the i-th row of @var{q} contains
-% ## the @var{p}(i)th quantiles of each column of @var{x}.
-% ##
-% ## If @var{p} is unspecified, return the quantiles for
-% ## @code{[0.00 0.25 0.50 0.75 1.00]}.
-% ## The optional argument @var{dim} determines the dimension along which
-% ## the quantiles are calculated.  If @var{dim} is omitted, and @var{x} is
-% ## a vector or matrix, it defaults to 1 (column-wise quantiles).  If
-% ## @var{x} is an N-D array, @var{dim} defaults to the first non-singleton
-% ## dimension.
-% ##
-% ## The methods available to calculate sample quantiles are the nine methods
-% ## used by R (@url{http://www.r-project.org/}).  The default value is
-% ## @w{METHOD = 5}.
-% ##
-% ## Discontinuous sample quantile methods 1, 2, and 3
-% ##
-% ## @enumerate 1
-% ## @item Method 1: Inverse of empirical distribution function.
-% ##
-% ## @item Method 2: Similar to method 1 but with averaging at discontinuities.
-% ##
-% ## @item Method 3: SAS definition: nearest even order statistic.
-% ## @end enumerate
-% ##
-% ## Continuous sample quantile methods 4 through 9, where p(k) is the linear
-% ## interpolation function respecting each methods' representative cdf.
-% ##
-% ## @enumerate 4
-% ## @item Method 4: p(k) = k / n.  That is, linear interpolation of the
-% ## empirical cdf.
-% ##
-% ## @item Method 5: p(k) = (k - 0.5) / n.  That is a piecewise linear function
-% ## where the knots are the values midway through the steps of the empirical
-% ## cdf.
-% ##
-% ## @item Method 6: p(k) = k / (n + 1).
-% ##
-% ## @item Method 7: p(k) = (k - 1) / (n - 1).
-% ##
-% ## @item Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting quantile
-% ## estimates are approximately median-unbiased regardless of the distribution
-% ## of @var{x}.
-% ##
-% ## @item Method 9: p(k) = (k - 3/8) / (n + 1/4).  The resulting quantile
-% ## estimates are approximately unbiased for the expected order statistics if
-% ## @var{x} is normally distributed.
-% ## @end enumerate
-% ##
-% ## Hyndman and Fan (1996) recommend method 8.  Maxima, S, and R
-% ## (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS
-% ## use method 6.  @sc{matlab} uses method 5.
-% ##
-% ## References:
-% ##
-% ## @itemize @bullet
-% ## @item Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New
-% ## S Language.  Wadsworth & Brooks/Cole.
-% ##
-% ## @item Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in
-% ## statistical packages, American Statistician, 50, 361--365.
-% ##
-% ## @item R: A Language and Environment for Statistical Computing;
-% ## @url{http://cran.r-project.org/doc/manuals/fullrefman.pdf}.
-% ## @end itemize
-% ##
-% ## Examples:
-% ## @c Set example in small font to prevent overfull line
-% ##
-% ## @smallexample
-% ## @group
-% ## x = randi (1000, [10, 1]);  # Create empirical data in range 1-1000
-% ## q = quantile (x, [0, 1]);   # Return minimum, maximum of distribution
-% ## q = quantile (x, [0.25 0.5 0.75]); # Return quartiles of distribution
-% ## @end group
-% ## @end smallexample
-% ## @seealso{prctile}
-% ## @end deftypefn
-%
-% ## Author: Ben Abbott <bpabbott@mac.com>
-% ## Description: Matlab style quantile function of a discrete/continuous distribution
-
-function q = quantile (x, p, dim, method)
-
-if nargin < 2,
-    p = [];
-end
-
-if nargin < 3,
-    dim = 1;
-end
-
-if nargin < 4,
-    % Use Matlab compatiblity mode
-    method = 5;
-end
-
-if (~ (isnumeric (x) || islogical (x)))
-    error ('quantile: X must be a numeric vector or matrix');
-end
-
-if (isempty (p))
-    p = [0.00 0.25, 0.50, 0.75, 1.00];
-end
-
-if (~ (isnumeric (p) && isvector (p)))
-    error ('quantile: P must be a numeric vector');
-end
-
-if (~ (isscalar (dim) && dim == fix (dim)) ...
-        || ~(1 <= dim && dim <= ndims (x)))
-    error ('quantile: DIM must be an integer and a valid dimension');
-end
-
-% Set the permutation vector.
-perm = 1:ndims (x);
-perm(1) = dim;
-perm(dim) = 1;
-
-% Permute dim to the 1st index.
-x = permute (x, perm);
-
-% Save the size of the permuted x N-d array.
-sx = size (x);
-
-% Reshape to a 2-d array.
-x = reshape (x, [sx(1), prod(sx(2:end))]);
-
-% Calculate the quantiles.
-q = octave__quantile__ (x, p, method);
-
-% Return the shape to the original N-d array.
-q = reshape (q, [numel(p), sx(2:end)]);
-
-% Permute the 1st index back to dim.
-q = ipermute (q, perm);
-
-end % function
-
-%!test
-%! p = 0.5;
-%! x = sort (rand (11));
-%! q = quantile (x, p);
-%! assert (isequal (q, x(6,:)));
-%! x = x.';
-%! q = quantile (x, p, 2);
-%! assert (isequal (q, x(:,6)));
-
-% Note: method 3 not available yet because Matlab doesn't have roundb()
-
-%!test
-%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
-%! x = [1; 2; 3; 4];
-%! a = [1.0000   1.0000   2.0000   3.0000   4.0000
-%!      1.0000   1.5000   2.5000   3.5000   4.0000
-%!      1.0000   1.0000   2.0000   3.0000   4.0000
-%!      1.0000   1.0000   2.0000   3.0000   4.0000
-%!      1.0000   1.5000   2.5000   3.5000   4.0000
-%!      1.0000   1.2500   2.5000   3.7500   4.0000
-%!      1.0000   1.7500   2.5000   3.2500   4.0000
-%!      1.0000   1.4167   2.5000   3.5833   4.0000
-%!      1.0000   1.4375   2.5000   3.5625   4.0000];
-%! for m = [1:2 4:9]
-%!   q = quantile (x, p, 1, m).';
-%!   assert (stk_isequal_tolabs (q, a(m,:), 0.0001));
-%! end
-
-%!test
-%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
-%! x = [1; 2; 3; 4; 5];
-%! a = [1.0000   2.0000   3.0000   4.0000   5.0000
-%!      1.0000   2.0000   3.0000   4.0000   5.0000
-%!      1.0000   1.0000   2.0000   4.0000   5.0000
-%!      1.0000   1.2500   2.5000   3.7500   5.0000
-%!      1.0000   1.7500   3.0000   4.2500   5.0000
-%!      1.0000   1.5000   3.0000   4.5000   5.0000
-%!      1.0000   2.0000   3.0000   4.0000   5.0000
-%!      1.0000   1.6667   3.0000   4.3333   5.0000
-%!      1.0000   1.6875   3.0000   4.3125   5.0000];
-%! for m = [1:2 4:9]
-%!   q = quantile (x, p, 1, m).';
-%!   assert (stk_isequal_tolabs (q, a(m,:), 0.0001));
-%! end
-
-%!test
-%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
-%! x = [1; 2; 5; 9];
-%! a = [1.0000   1.0000   2.0000   5.0000   9.0000
-%!      1.0000   1.5000   3.5000   7.0000   9.0000
-%!      1.0000   1.0000   2.0000   5.0000   9.0000
-%!      1.0000   1.0000   2.0000   5.0000   9.0000
-%!      1.0000   1.5000   3.5000   7.0000   9.0000
-%!      1.0000   1.2500   3.5000   8.0000   9.0000
-%!      1.0000   1.7500   3.5000   6.0000   9.0000
-%!      1.0000   1.4167   3.5000   7.3333   9.0000
-%!      1.0000   1.4375   3.5000   7.2500   9.0000];
-%! for m = [1:2 4:9]
-%!   q = quantile (x, p, 1, m).';
-%!   assert (stk_isequal_tolabs (q, a(m,:), 0.0001));
-%! end
-
-%!test
-%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
-%! x = [1; 2; 5; 9; 11];
-%! a = [1.0000    2.0000    5.0000    9.0000   11.0000
-%!      1.0000    2.0000    5.0000    9.0000   11.0000
-%!      1.0000    1.0000    2.0000    9.0000   11.0000
-%!      1.0000    1.2500    3.5000    8.0000   11.0000
-%!      1.0000    1.7500    5.0000    9.5000   11.0000
-%!      1.0000    1.5000    5.0000   10.0000   11.0000
-%!      1.0000    2.0000    5.0000    9.0000   11.0000
-%!      1.0000    1.6667    5.0000    9.6667   11.0000
-%!      1.0000    1.6875    5.0000    9.6250   11.0000];
-%! for m = [1:2 4:9]
-%!   q = quantile (x, p, 1, m).';
-%!   assert (stk_isequal_tolabs (q, a(m,:), 0.0001));
-%! end
-
-%!test
-%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
-%! x = [16; 11; 15; 12; 15;  8; 11; 12;  6; 10];
-%! a = [6.0000   10.0000   11.0000   15.0000   16.0000
-%!      6.0000   10.0000   11.5000   15.0000   16.0000
-%!      6.0000    8.0000   11.0000   15.0000   16.0000
-%!      6.0000    9.0000   11.0000   13.5000   16.0000
-%!      6.0000   10.0000   11.5000   15.0000   16.0000
-%!      6.0000    9.5000   11.5000   15.0000   16.0000
-%!      6.0000   10.2500   11.5000   14.2500   16.0000
-%!      6.0000    9.8333   11.5000   15.0000   16.0000
-%!      6.0000    9.8750   11.5000   15.0000   16.0000];
-%! for m = [1:2 4:9]
-%!   q = quantile (x, p, 1, m).';
-%!   assert (stk_isequal_tolabs (q, a(m,:), 0.0001));
-%! end
-
-%!test
-%! p = [0.00, 0.25, 0.50, 0.75, 1.00];
-%! x = [-0.58851;  0.40048;  0.49527; -2.551500; -0.52057; ...
-%!      -0.17841; 0.057322; -0.62523;  0.042906;  0.12337];
-%! a = [-2.551474  -0.588505  -0.178409   0.123366   0.495271
-%!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
-%!      -2.551474  -0.625231  -0.178409   0.123366   0.495271
-%!      -2.551474  -0.606868  -0.178409   0.090344   0.495271
-%!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
-%!      -2.551474  -0.597687  -0.067751   0.192645   0.495271
-%!      -2.551474  -0.571522  -0.067751   0.106855   0.495271
-%!      -2.551474  -0.591566  -0.067751   0.146459   0.495271
-%!      -2.551474  -0.590801  -0.067751   0.140686   0.495271];
-%! for m = [1:2 4:9]
-%!   q = quantile (x, p, 1, m).';
-%!   assert (stk_isequal_tolabs (q, a(m,:), 0.0001));
-%! end
-
-%!test
-%! p = 0.5;
-%! x = [0.112600, 0.114800, 0.052100, 0.236400, 0.139300
-%!      0.171800, 0.727300, 0.204100, 0.453100, 0.158500
-%!      0.279500, 0.797800, 0.329600, 0.556700, 0.730700
-%!      0.428800, 0.875300, 0.647700, 0.628700, 0.816500
-%!      0.933100, 0.931200, 0.963500, 0.779600, 0.846100];
-%! tol = 0.00001;
-%! x(5,5) = NaN;
-%! assert (stk_isequal_tolabs ...
-%!           (quantile (x, p, 1), ...
-%!            [0.27950, 0.79780, 0.32960, 0.55670, 0.44460], tol));
-%! x(1,1) = NaN;
-%! assert (stk_isequal_tolabs ...
-%!           (quantile (x, p, 1), ...
-%!            [0.35415, 0.79780, 0.32960, 0.55670, 0.44460], tol));
-%! x(3,3) = NaN;
-%! assert (stk_isequal_tolabs ...
-%!           (quantile (x, p, 1), ...
-%!            [0.35415, 0.79780, 0.42590, 0.55670, 0.44460], tol));
-
-%!test
-%! sx = [2, 3, 4];
-%! x = rand (sx);
-%! dim = 2;
-%! p = 0.5;
-%! yobs = quantile (x, p, dim);
-%! yexp = median (x, dim);
-%! assert (isequal (yobs, yexp));
-
-%% Test input validation
-%!error quantile ()
-%!error quantile (1, 2, 3, 4, 5)
-%!error quantile (['A'; 'B'], 10)
-%!error quantile (1:10, [true, false])
-%!error quantile (1:10, ones (2,2))
-%!error quantile (1, 1, 1.5)
-%!error quantile (1, 1, 0)
-%!error quantile (1, 1, 3)
-%!error quantile ((1:5)', 0.5, 1, 0)
-%!error quantile ((1:5)', 0.5, 1, 10)
-
-% ## For the cumulative probability values in @var{p}, compute the
-% ## quantiles, @var{q} (the inverse of the cdf), for the sample, @var{x}.
-% ##
-% ## The optional input, @var{method}, refers to nine methods available in R
-% ## (http://www.r-project.org/). The default is @var{method} = 7.
-% ## @seealso{prctile, quantile, statistics}
-%
-% ## Author: Ben Abbott <bpabbott@mac.com>
-% ## Vectorized version: Jaroslav Hajek <highegg@gmail.com>
-% ## Description: Quantile function of empirical samples
-
-function inv = octave__quantile__ (x, p, method)
-
-if (isinteger (x) || islogical (x))
-    x = double (x);
-end
-
-% set shape of quantiles to column vector.
-p = p(:);
-
-% Save length and set shape of samples.
-% FIXME: does sort guarantee that NaN's come at the end?
-x = sort (x);
-m = sum (~ isnan (x));
-[xr, xc] = size (x);
-
-% Initialize output values.
-inv = Inf (class (x)) * (-(p < 0) + (p > 1));
-inv = repmat (inv, 1, xc);
-
-% Do the work.
-k = find ((p >= 0) & (p <= 1));
-if (any (k))
-    n = length (k);
-    p = p(k);
-    % Special case of 1 row.
-    if (xr == 1)
-        inv(k,:) = repmat (x, n, 1);
-        return;
-    end
-    
-    % The column-distribution indices.
-    pcd = kron (ones (n, 1), xr*(0:xc-1));
-    mm = kron (ones (n, 1), m);
-    switch (method)
-        case {1, 2, 3}
-            switch (method)
-                case 1
-                    p = max (ceil (kron (p, m)), 1);
-                    inv(k,:) = x(p + pcd);
-                    
-                case 2
-                    p = kron (p, m);
-                    p_lr = max (ceil (p), 1);
-                    p_rl = min (floor (p + 1), mm);
-                    inv(k,:) = (x(p_lr + pcd) + x(p_rl + pcd))/2;
-                    
-                case 3
-                    % Used by SAS, method PCTLDEF=2.
-                    % http://support.sas.com/onlinedoc/913/getDoc/en/statug.hlp/stdize_sect14.htm
-                    t = max (kron (p, m), 1);
-                    t = roundb (t);
-                    inv(k,:) = x(t + pcd);
-            end
-            
-        otherwise
-            switch (method)
-                case 4
-                    p = kron (p, m);
-                    
-                case 5
-                    % Used by Matlab.
-                    p = kron (p, m) + 0.5;
-                    
-                case 6
-                    % Used by Minitab and SPSS.
-                    p = kron (p, m+1);
-                    
-                case 7
-                    % Used by S and R.
-                    p = kron (p, m-1) + 1;
-                    
-                case 8
-                    % Median unbiased.
-                    p = kron (p, m+1/3) + 1/3;
-                    
-                case 9
-                    % Approximately unbiased respecting order statistics.
-                    p = kron (p, m+0.25) + 0.375;
-                    
-                otherwise
-                    error ('quantile: Unknown METHOD, ''%d''', method);
-            end
-            
-            % Duplicate single values.
-            imm1 = (mm == 1);
-            x(2,imm1) = x(1,imm1);
-            
-            % Interval indices.
-            pi = max (min (floor (p), mm-1), 1);
-            pr = max (min (p - pi, 1), 0);
-            pi = pi + pcd;
-            inv(k,:) = (1-pr) .* x(pi) + pr .* x(pi+1);
-    end
-end
-
-end % function
